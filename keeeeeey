type Config struct {
	AWSAccessKeyID     string `yaml:"CAAS_UI_AWS_ACCESS_KEY_ID"`
	AWSSecretAccessKey string `yaml:"CAAS_UI_AWS_SECRET_ACCESS_KEY"`
	BaseURL            string `yaml:"BASE_URL"`
	AppEnv             string `yaml:"APP_ENV"`
}

---

// pkg/config/config.go
package config

import (
	"log"
	"os"
	"sync"
	
	"github.com/fsnotify/fsnotify"
	"gopkg.in/yaml.v3"
)

// (Aquí iría tu struct Config)
type Config struct { ... }

var (
	currentConfig Config
	configMutex   sync.RWMutex
)

// Init carga la configuración inicial y empieza a vigilar el archivo.
func Init(path string) {
	loadConfig(path)
	go watchConfigFile(path)
}

// Get devuelve la configuración actual de forma segura.
func Get() Config {
	configMutex.RLock()
	defer configMutex.RUnlock()
	return currentConfig
}

// (Aquí irían las funciones loadConfig y watchConfigFile)
func loadConfig(path string) { ... }
func loadConfig() {
	log.Println("Cargando/Recargando configuración desde", configPath)
	data, err := os.ReadFile(configPath)
	if err != nil {
		log.Printf("ERROR: No se pudo leer el archivo de configuración: %v", err)
		return
	}

	var newConfig Config
	if err := yaml.Unmarshal(data, &newConfig); err != nil {
		log.Printf("ERROR: No se pudo decodificar el YAML: %v", err)
		return
	}

	configMutex.Lock()
	currentConfig = newConfig
	configMutex.Unlock()

	log.Println("¡Configuración cargada/actualizada exitosamente!")
}


func watchConfigFile(path string) { ... }
func watchConfigFile() {
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		log.Fatalf("Error creating file watcher:: %v", err)
	}
	defer watcher.Close()

	if err := watcher.Add("/config"); err != nil {
		log.Fatalf("Error adding directory to watcher: %v", err)
	}

	log.Printf("Watching for changes in %s", configPath)

	for {
		select {
		case event, ok := <-watcher.Events:
			if !ok { return }
			if (event.Has(fsnotify.Write) || event.Has(fsnotify.Create)) && event.Name == configPath {
				loadConfig()
			}
		case err, ok := <-watcher.Errors:
			if !ok { return }
			log.Printf("Error del vigilante: %v", err)
		}
	}
}


func main() {
    // Simplemente inicializas la configuración
    config.Init("/etc/config/config.yaml")

    // Y cuando necesites un valor, lo pides
    // cfg := config.Get()
    // dbHost := cfg.Database.Host

    // ... resto de la lógica ...
}

Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
SHELL := powershell.exe -NoProfile -ExecutionPolicy Bypass -Command

---

package config

import (
	"os"
	"testing"
)

func TestConfigLoading(t *testing.T) {

	// Caso de Éxito: Cargar una configuración válida
	t.Run("Carga exitosa con YAML válido", func(t *testing.T) {
		// Contenido YAML que coincide con la estructura Config
		yamlContent := `
CAAS_UI_AWS_ACCESS_KEY_ID: "AKIAIOSFODNN7EXAMPLE"
CAAS_UI_AWS_SECRET_ACCESS_KEY: "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
BASE_URL: "http://localhost:8080"
APP_ENV: "development"
`
		// Crear un archivo temporal para la prueba
		tmpfile, err := os.CreateTemp("", "config-*.yaml")
		if err != nil {
			t.Fatalf("No se pudo crear el archivo temporal: %v", err)
		}
		// Asegurarse de que el archivo se elimine al finalizar la prueba
		defer os.Remove(tmpfile.Name())

		if _, err := tmpfile.Write([]byte(yamlContent)); err != nil {
			t.Fatalf("No se pudo escribir en el archivo temporal: %v", err)
		}
		tmpfile.Close()

		// Llamar a la función Init con la ruta de nuestro archivo temporal
		Init(tmpfile.Name())

		// Verificar que la configuración se cargó correctamente usando GetCfg
		cfg := GetCfg()
		
		expectedKeyID := "AKIAIOSFODNN7EXAMPLE"
		if cfg.AwsAccessKeyID != expectedKeyID {
			t.Errorf("Se esperaba AwsAccessKeyID '%s', pero se obtuvo '%s'", expectedKeyID, cfg.AwsAccessKeyID)
		}

		expectedBaseURL := "http://localhost:8080"
		if cfg.BaseURL != expectedBaseURL {
			t.Errorf("Se esperaba BaseURL '%s', pero se obtuvo '%s'", expectedBaseURL, cfg.BaseURL)
		}

		expectedAppEnv := "development"
		if cfg.AppEnv != expectedAppEnv {
			t.Errorf("Se esperaba AppEnv '%s', pero se obtuvo '%s'", expectedAppEnv, cfg.AppEnv)
		}
	})

	// Caso de Error: Archivo no encontrado
	t.Run("Error cuando el archivo no existe", func(t *testing.T) {
		// Reiniciamos la variable global para esta prueba
		currentConfig = Config{}
		
		// Llamamos a Init con una ruta que sabemos que no existe
		Init("ruta/inexistente/config.yaml")

		cfg := GetCfg()
		// Verificamos que la configuración global siga vacía (zero value)
		if cfg.BaseURL != "" {
			t.Error("La configuración no debería haber cambiado si el archivo no existe")
		}
	})

	// Caso de Error: YAML inválido
	t.Run("Error con formato YAML inválido", func(t *testing.T) {
		// Reiniciamos la variable global
		currentConfig = Config{}

		// Contenido con YAML malformado (un tabulador en lugar de espacios)
		invalidYaml := "BASE_URL: \t 'url-invalida'"

		tmpfile, err := os.CreateTemp("", "invalid-*.yaml")
		if err != nil {
			t.Fatalf("No se pudo crear el archivo temporal: %v", err)
		}
		defer os.Remove(tmpfile.Name())

		if _, err := tmpfile.Write([]byte(invalidYaml)); err != nil {
			t.Fatalf("No se pudo escribir en el archivo temporal: %v", err)
		}
		tmpfile.Close()

		Init(tmpfile.Name())

		// Verificamos que la configuración no haya sido alterada
		cfg := GetCfg()
		if cfg.BaseURL != "" {
			t.Error("La configuración no debería haber cambiado con un YAML inválido")
		}
	})
}


---
// ... (código anterior)

		if _, err := tmpfile.Write([]byte(yamlContent)); err != nil {
			// TRADUCCIÓN: "No se pudo escribir en el archivo temporal"
			t.Fatalf("Failed to write to temporary file: %v", err)
		}
		tmpfile.Close()

		Init(tmpfile.Name())

		cfg := GetCfg()

		expectedKeyID := "AKIAIOSFODNN7EXAMPLE"
		if cfg.AwsAccessKeyID != expectedKeyID {
			// TRADUCCIÓN: "Se esperaba ... pero se obtuvo ..."
			t.Errorf("Expected AwsAccessKeyID '%s', but got '%s'", expectedKeyID, cfg.AwsAccessKeyID)
		}

		expectedBaseURL := "http://localhost:8080"
		if cfg.BaseURL != expectedBaseURL {
			// TRADUCCIÓN: "Se esperaba ... pero se obtuvo ..."
			t.Errorf("Expected BaseURL '%s', but got '%s'", expectedBaseURL, cfg.BaseURL)
		}

		expectedAppEnv := "development"
		if cfg.AppEnv != expectedAppEnv {
			// TRADUCCIÓN: "Se esperaba ... pero se obtuvo ..."
			t.Errorf("Expected AppEnv '%s', but got '%s'", expectedAppEnv, cfg.AppEnv)
		}

		// ... (código posterior)

---

Of course. Here is a detailed report in English, formatted as a JIRA ticket comment, based on the changes you've provided and the context you've shared.

Technical Proposal: Refactor Configuration Loading from Environment Variables to a File-Based Approach
This comment details a set of proposed changes to refactor the application's configuration mechanism. The primary goal is to move from using environment variables to a more structured, file-based approach using a config.yaml file. This change provides a centralized and version-controllable way to manage application settings. This involves modifications to both the Go application code and the Helm chart used for Kubernetes deployments.

1. Helm Chart Modifications
To support the new configuration method, several changes were introduced to the Helm chart.

ConfigMap Template Creation (templates/configmap.yaml)
A new Helm template has been created to dynamically generate a Kubernetes ConfigMap. This ConfigMap contains a single key, config.yaml, whose content is populated directly from values defined in the Helm values.yaml file. This allows for environment-specific configurations to be managed cleanly through Helm values.

Deployment Manifest Update (templates/deployment.yaml)
The deployment.yaml has been updated to stop injecting configuration as environment variables. The env and envFrom sections, which previously pulled values from secrets and other sources, have been removed. Instead, the deployment now mounts the newly created ConfigMap as a volume. The config.yaml key from the ConfigMap is mounted directly into the container at the path /config/config.yaml.

values.yaml Structure Update
A new section, configData, has been added to the values.yaml file. This section serves as the new, centralized location for all application-level configuration that was previously managed by individual values. The Helm chart templates were also updated to define the volume and volume mount that consumes the ConfigMap.

2. Application Code Modifications (Golang)
Significant changes were made to the application's bootstrap process to handle the new configuration loading mechanism.

New Configuration Package (pkg/config/config.go)
A dedicated package for configuration has been developed. It uses a singleton pattern to ensure that the configuration is loaded only once and is accessible globally throughout the application via config.GetCfg().

File Reading and Parsing Logic
The core of the new package is the Init(path) function, which is called once at application startup. This function triggers loadConfig(path), which reads the file from the provided path, and then uses the gopkg.in/yaml.v3 library to unmarshal the YAML content into a new Config struct.

Updated Config Struct
The Config struct has been modified to use yaml tags instead of relying on environment variable libraries. These tags map the keys in the config.yaml file directly to the corresponding fields in the struct.

Integration in main.go
The application's entry point in main.go has been updated. The first action it now performs is calling config.Init("/config/config.yaml"). This hardcoded path directly corresponds to the mount path defined in the Kubernetes deployment.yaml, ensuring the application finds its configuration file when running in the cluster.

3. Current Status and Next Steps
IMPORTANT: These changes have been developed but are currently paused and have not been applied to any environment.

The primary reason for pausing this implementation is the direct impact it would have on the local development workflow for our engineering teams. Currently, developers run the application on their local machines by setting environment variables. If these changes were merged, this workflow would break, as the application would now exclusively look for a /config/config.yaml file, which is not present in their local setups.

To move forward, we need to coordinate with the development teams to devise a strategy that supports both local and deployed environments. Potential strategies include:

Establishing a convention for developers to maintain a local config.yaml file for their environment.

Enhancing the Go configuration code to implement a fallback mechanism: first, attempt to load the config.yaml file, and if it's not found, then attempt to populate the configuration from environment variables as a secondary option.

Providing a standardized config.yaml.example file in the repository to guide local setup.

We recommend scheduling a meeting to discuss these options and define a clear, non-disruptive rollout plan before merging these changes.
